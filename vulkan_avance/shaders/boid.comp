#version 450

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

struct Boid {
    mat4 world;
};

struct BoidVelocity {
    vec4 velocity;
};

layout(set = 0, binding = 0) readonly buffer InstanceBufferIn {
    Boid boidsIn[];
};

layout(set = 0, binding = 1) readonly buffer VelocityBufferIn {
    BoidVelocity velocitiesIn[];
};

layout(set = 0, binding = 2) buffer InstanceBufferOut {
    Boid boidsOut[];
};

layout(set = 0, binding = 3) buffer VelocityBufferOut {
    BoidVelocity velocitiesOut[];
};

layout(set = 0, binding = 4) uniform SimulationParams {
    float deltaTime;
    float separationDistance;
    float alignmentDistance;
    float cohesionDistance;
    float separationWeight;
    float alignmentWeight;
    float cohesionWeight;
    float maxSpeed;
    float minSpeed;
    uint boidCount;
    vec3 boundaryMin;
    vec3 boundaryMax;
} params;

vec3 getPosition(mat4 world) {
    return world[3].xyz;
}

mat4 createWorldMatrix(vec3 position, vec3 direction) {
    vec3 forward = normalize(direction);
    vec3 worldUp = vec3(0.0, 1.0, 0.0);
    if (abs(dot(forward, worldUp)) > 0.99) {
        worldUp = vec3(1.0, 0.0, 0.0);
    }
    
    vec3 right = normalize(cross(worldUp, forward));
    vec3 up = cross(forward, right);

    return mat4(
        vec4(right, 0.0),
        vec4(up, 0.0),
        vec4(forward, 0.0),
        vec4(position, 1.0)
    );
}

vec3 applyBoundaries(vec3 position) {
    vec3 newPos = position;
    
    if (newPos.x < -25) newPos.x = 24;
    if (newPos.x >  25) newPos.x = -24;
    if (newPos.y < -25) newPos.y = 24;
    if (newPos.y >  25) newPos.y = -24;
    if (newPos.z < -25) newPos.z = 24;
    if (newPos.z >  25) newPos.z = -24;
    
    return newPos;
}

void main() {
    uint boidId = gl_GlobalInvocationID.x;
    if (boidId >= params.boidCount) {
        return;
    }
    
    vec3 myPosition = getPosition(boidsIn[boidId].world);
    vec3 myVelocity = velocitiesIn[boidId].velocity.xyz;
    
    vec3 separation = vec3(0.0);
    vec3 alignment = vec3(0.0);
    vec3 cohesion = vec3(0.0);
    
    int separationCount = 0;
    int alignmentCount = 0;
    int cohesionCount = 0;

    for (uint i = 0; i < params.boidCount; i++) {
        if (i == boidId) continue;

        vec3 otherPosition = getPosition(boidsIn[i].world);
        vec3 otherVelocity = velocitiesIn[i].velocity.xyz;
        
        vec3 offset = otherPosition - myPosition;
        float distance = length(offset);

        if (distance < params.separationDistance && distance > 0.001) {
            separation -= offset / distance;
            separationCount++;
        }
        
        if (distance < params.alignmentDistance) {
            alignment += otherVelocity;
            alignmentCount++;
        }
        
        if (distance < params.cohesionDistance) {
            cohesion += otherPosition;
            cohesionCount++;
        }
    }
    
    vec3 steer = vec3(0.0);

    if (separationCount > 0) {
        separation /= float(separationCount);
        steer += separation * params.separationWeight;
    }
    
    if (alignmentCount > 0) {
        alignment /= float(alignmentCount);
        steer += (alignment - myVelocity) * params.alignmentWeight;
    }
    
    if (cohesionCount > 0) {
        cohesion /= float(cohesionCount);
        vec3 desired = cohesion - myPosition;
        steer += desired * params.cohesionWeight;
    }
    
    vec3 newVelocity = myVelocity + steer * params.deltaTime;
    
    float speed = length(newVelocity);
    if (speed > params.maxSpeed) {
        newVelocity = (newVelocity / speed) * params.maxSpeed;
    } else if (speed < params.minSpeed && speed > 0.001) {
        newVelocity = (newVelocity / speed) * params.minSpeed;
    }
    
    vec3 newPosition = myPosition + newVelocity * params.deltaTime;
    newPosition = applyBoundaries(newPosition);

    velocitiesOut[boidId].velocity = vec4(newVelocity, 0.0);
    boidsOut[boidId].world = createWorldMatrix(newPosition, newVelocity);
}